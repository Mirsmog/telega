"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.needsEnumNameMatchingEnumType = exports.hasEnumSpecifiedCorrectly = void 0;
const utils_1 = require("@typescript-eslint/utils");
const createRule_1 = require("../../utils/createRule");
const typedTokenHelpers_1 = require("../../utils/typedTokenHelpers");
const enumTestResultModel_1 = require("./enumTestResultModel");
const noChangesRequiredResult = new enumTestResultModel_1.EnumTestResultModel({
    needsEnumAdded: false,
    needsEnumNameAdded: false,
    needsEnumNameToMatchEnumType: false,
    needsTypeRemoved: false,
});
const hasEnumSpecifiedCorrectly = (node, isEnumType) => {
    // is this an enum
    if (!isEnumType) {
        return noChangesRequiredResult;
    }
    // is this decorated with api documentation
    const decorators = typedTokenHelpers_1.typedTokenHelpers.getDecoratorsNamed(node, ["ApiPropertyOptional", "ApiProperty"]);
    if (decorators.length === 0) {
        return noChangesRequiredResult;
    }
    // check if there is an enum property in the provided options (enums should specify the enum property)
    const firstArgument = decorators[0].expression
        .arguments[0];
    if (!firstArgument) {
        return new enumTestResultModel_1.EnumTestResultModel({
            needsEnumAdded: true,
            needsEnumNameAdded: true,
            needsEnumNameToMatchEnumType: false,
            needsTypeRemoved: false,
        });
    }
    const enumProperty = firstArgument.properties.find((p) => p.key.name ===
        "enum");
    // check if there is a type: property in the provided options (enums shouldn't specify type)
    const hasTypeProperty = firstArgument.properties.find((p) => p.key.name ===
        "type") !== undefined;
    // check if there is an enumName: property in the provided options (enums should specify a name)
    const enumNameProperty = firstArgument.properties.find((p) => p.key.name ===
        "enumName");
    return new enumTestResultModel_1.EnumTestResultModel({
        needsEnumAdded: enumProperty === undefined,
        needsEnumNameAdded: enumNameProperty === undefined,
        needsEnumNameToMatchEnumType: (0, exports.needsEnumNameMatchingEnumType)(enumNameProperty, enumProperty),
        needsTypeRemoved: hasTypeProperty,
    });
};
exports.hasEnumSpecifiedCorrectly = hasEnumSpecifiedCorrectly;
const needsEnumNameMatchingEnumType = (enumNameProperty, enumProperty) => {
    // if enum props aren't specified we don't care about this scenario
    if (enumNameProperty === undefined || enumProperty === undefined) {
        return false;
    }
    const isEnumNameMatchingEnumType = enumNameProperty.value.value ===
        enumProperty.value.name;
    return !isEnumNameMatchingEnumType;
};
exports.needsEnumNameMatchingEnumType = needsEnumNameMatchingEnumType;
const rule = (0, createRule_1.createRule)({
    name: "api-enum-property-best-practices",
    meta: {
        docs: {
            description: "Enums should use the best practices for api documentation",
        },
        messages: {
            needsEnumNameAdded: `Properties with enum should also specify an enumName property to keep generated models clean`,
            needsTypeRemoved: `Properties with enum should not specify a type property`,
            enumNameShouldMatchType: `The enumName should match the enum type provided`,
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        //const globalScope = context.getScope();
        const parserServices = utils_1.ESLintUtils.getParserServices(context);
        const typeChecker = parserServices.program.getTypeChecker();
        return {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            PropertyDefinition(node) {
                const mappedNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                const objectType = typeChecker.getTypeAtLocation(mappedNode);
                const isEnumType = typedTokenHelpers_1.typedTokenHelpers.isEnumType(objectType);
                const result = (0, exports.hasEnumSpecifiedCorrectly)(node, isEnumType);
                if (result.needsEnumNameAdded) {
                    context.report({
                        node: node,
                        messageId: "needsEnumNameAdded",
                    });
                }
                if (result.needsTypeRemoved) {
                    context.report({
                        node: node,
                        messageId: "needsTypeRemoved",
                    });
                }
                if (result.needsEnumNameToMatchEnumType) {
                    context.report({
                        node: node,
                        messageId: "enumNameShouldMatchType",
                    });
                }
            },
        };
    },
});
exports.default = rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpRW51bVByb3BlcnR5QmVzdFByYWN0aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydWxlcy9hcGlFbnVtUHJvcGVydHlCZXN0UHJhY3RpY2VzL2FwaUVudW1Qcm9wZXJ0eUJlc3RQcmFjdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsb0RBQStEO0FBQy9ELHVEQUFrRDtBQUNsRCxxRUFBZ0U7QUFDaEUsK0RBQTBEO0FBRTFELE1BQU0sdUJBQXVCLEdBQUcsSUFBSSx5Q0FBbUIsQ0FBQztJQUNwRCxjQUFjLEVBQUUsS0FBSztJQUNyQixrQkFBa0IsRUFBRSxLQUFLO0lBQ3pCLDRCQUE0QixFQUFFLEtBQUs7SUFDbkMsZ0JBQWdCLEVBQUUsS0FBSztDQUMxQixDQUFDLENBQUM7QUFFSSxNQUFNLHlCQUF5QixHQUFHLENBQ3JDLElBQW1CLEVBQ25CLFVBQW1CLEVBQ0EsRUFBRTtJQUNyQixrQkFBa0I7SUFDbEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2QsT0FBTyx1QkFBdUIsQ0FBQztJQUNuQyxDQUFDO0lBRUQsMkNBQTJDO0lBQzNDLE1BQU0sVUFBVSxHQUFHLHFDQUFpQixDQUFDLGtCQUFrQixDQUNuRCxJQUFtQyxFQUNuQyxDQUFDLHFCQUFxQixFQUFFLGFBQWEsQ0FBQyxDQUN6QyxDQUFDO0lBRUYsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQzFCLE9BQU8sdUJBQXVCLENBQUM7SUFDbkMsQ0FBQztJQUVELHNHQUFzRztJQUN0RyxNQUFNLGFBQWEsR0FBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBc0M7U0FDdEUsU0FBUyxDQUFDLENBQUMsQ0FBOEIsQ0FBQztJQUMvQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDakIsT0FBTyxJQUFJLHlDQUFtQixDQUFDO1lBQzNCLGNBQWMsRUFBRSxJQUFJO1lBQ3BCLGtCQUFrQixFQUFF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