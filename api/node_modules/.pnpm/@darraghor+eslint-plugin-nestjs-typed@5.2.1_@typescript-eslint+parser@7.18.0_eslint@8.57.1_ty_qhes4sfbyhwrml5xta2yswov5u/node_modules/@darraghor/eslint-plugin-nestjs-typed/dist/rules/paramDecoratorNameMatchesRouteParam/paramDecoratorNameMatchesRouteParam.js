"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldTrigger = exports.isParameterNameIncludedInAPathPart = exports.hasPathPartsAnyRegexParams = exports.parsePathParts = void 0;
/* eslint-disable unicorn/prevent-abbreviations */
const utils_1 = require("@typescript-eslint/utils");
const createRule_1 = require("../../utils/createRule");
const nestRequestMethodDecoratorNames = new Set([
    "Get",
    "Post",
    "Put",
    "Delete",
    "Patch",
    "Options",
    "Head",
    "All",
]);
const parsePathParts = (decorator) => {
    const decoratorArgument = decorator?.expression
        ?.arguments[0];
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral ||
        decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
        return ["dareslint__skip"];
    }
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.Literal) {
        return [decoratorArgument.raw];
    }
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.ArrayExpression) {
        return decoratorArgument.elements.map((x) => x.raw);
    }
    if (decoratorArgument?.type === utils_1.TSESTree.AST_NODE_TYPES.ObjectExpression) {
        return decoratorArgument.properties
            .filter((x) => x?.key
            ?.name === "path")
            .map((x) => x.value.raw);
    }
    return [];
};
exports.parsePathParts = parsePathParts;
/**
 * nestjs allows for paths with _+?()*
 * this rule doesn't support parsing those so we'll just pass
 */
const hasPathPartsAnyRegexParams = (pathPartsToCheck) => {
    // prettier-ignore
    // eslint-disable-next-line no-useless-escape
    const specialCharacterRegex = /(dareslint__skip|\*|\+|\?|\(|\)|_)/; //new RegExp("([\?\+\*\_\(\)])")
    return pathPartsToCheck.some((pathPart) => {
        return specialCharacterRegex.test(pathPart);
    });
};
exports.hasPathPartsAnyRegexParams = hasPathPartsAnyRegexParams;
/**
 * Checks if there is a matching path part for the paramName
 * @param paramName
 * @param pathPartsToCheck
 * @returns
 */
const isParameterNameIncludedInAPathPart = (paramName, pathPartsToCheck) => {
    return pathPartsToCheck.some((pathPart) => {
        return (
        // note to reader: this might be better as a regex. feel free to open a pr!
        pathPart === `":${paramName}"` ||
            pathPart === `':${paramName}'` ||
            pathPart.includes(`/:${paramName}/`) ||
            pathPart.includes(`/:${paramName}"`) ||
            pathPart.includes(`":${paramName}/`) ||
            pathPart.includes(`/:${paramName}'`) ||
            pathPart.includes(`':${paramName}/`));
    });
};
exports.isParameterNameIncludedInAPathPart = isParameterNameIncludedInAPathPart;
const shouldTrigger = (decorator) => {
    if (!decorator) {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // grab the param name
    const paramName = decorator.expression
        ?.arguments[0]?.value;
    // if there's no param name get out of here
    if (!paramName || paramName === "") {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // param names don't need the colon
    if (paramName.startsWith(":")) {
        return {
            hasColonInName: true,
            paramNameNotMatchedInPath: false,
        };
    }
    let pathPartsToCheck = [];
    // grab any controller path parts
    // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
    const controllerDecorator = decorator.parent?.parent?.parent?.parent
        ?.parent?.decorators?.find((d) => {
        return (d.expression
            .callee?.name === "Controller");
    });
    pathPartsToCheck = pathPartsToCheck.concat((0, exports.parsePathParts)(controllerDecorator));
    // grab any api method path parts from method decorator
    const methodDefinition = decorator.parent?.parent
        ?.parent;
    // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
    const methodDecorator = methodDefinition?.decorators?.find((d) => {
        return nestRequestMethodDecoratorNames.has(d.expression
            .callee?.name);
    });
    pathPartsToCheck = pathPartsToCheck.concat((0, exports.parsePathParts)(methodDecorator));
    const shouldIgnoreThisSetOfRoutes = 
    // is a template literal argument
    // is an identifier argument
    (0, exports.hasPathPartsAnyRegexParams)(pathPartsToCheck);
    if (shouldIgnoreThisSetOfRoutes) {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // check that the param name is in one path part
    return {
        hasColonInName: false,
        paramNameNotMatchedInPath: !(0, exports.isParameterNameIncludedInAPathPart)(paramName, pathPartsToCheck),
    };
};
exports.shouldTrigger = shouldTrigger;
const rule = (0, createRule_1.createRule)({
    name: "param-decorator-name-matches-route-param",
    meta: {
        docs: {
            description: 'Param decorators with a name parameter e.g. Param("myvar") should match a specified route parameter - e.g. Get(":myvar")',
        },
        messages: {
            paramIdentifierDoesntNeedColon: "You don't need to specify the colon (:) in a Param decorator",
            paramIdentifierShouldMatch: 'Param decorators with identifiers e.g. Param("myvar") should match a specified route parameter - e.g. Get(":myvar")',
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        return {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            Decorator(node) {
                if (node.expression
                    ?.callee?.name !== "Param") {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/naming-convention
                const result = (0, exports.shouldTrigger)(node);
                if (result.paramNameNotMatchedInPath) {
                    context.report({
                        node: node,
                        messageId: "paramIdentifierShouldMatch",
                    });
                }
                if (result.hasColonInName) {
                    context.report({
                        node: node,
                        messageId: "paramIdentifierDoesntNeedColon",
                    });
                }
            },
        };
    },
});
exports.default = rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvcGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0vcGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsa0RBQWtEO0FBQ2xELG9EQUFrRDtBQUNsRCx1REFBa0Q7QUFPbEQsTUFBTSwrQkFBK0IsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUM1QyxLQUFLO0lBQ0wsTUFBTTtJQUNOLEtBQUs7SUFDTCxRQUFRO0lBQ1IsT0FBTztJQUNQLFNBQVM7SUFDVCxNQUFNO0lBQ04sS0FBSztDQUNSLENBQUMsQ0FBQztBQUVJLE1BQU0sY0FBYyxHQUFHLENBQUMsU0FBNkIsRUFBWSxFQUFFO0lBQ3RFLE1BQU0saUJBQWlCLEdBQUksU0FBUyxFQUFFLFVBQXNDO1FBQ3hFLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRW5CLElBQ0ksaUJBQWlCLEVBQUUsSUFBSSxLQUFLLGdCQUFRLENBQUMsY0FBYyxDQUFDLGVBQWU7UUFDbkUsaUJBQWlCLEVBQUUsSUFBSSxLQUFLLGdCQUFRLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFDaEUsQ0FBQztRQUNDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLGlCQUFpQixFQUFFLElBQUksS0FBSyxnQkFBUSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5RCxPQUFPLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELElBQUksaUJBQWlCLEVBQUUsSUFBSSxLQUFLLGdCQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3RFLE9BQU8saUJBQWlCLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FDakMs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