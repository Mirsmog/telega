"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const unambiguous = __importStar(require("eslint-module-utils/unambiguous"));
const fs_1 = __importDefault(require("fs"));
const typedTokenHelpers_1 = require("../typedTokenHelpers");
const nestModuleAstParser_1 = require("./nestModuleAstParser");
const nestProviderAstParser_1 = require("./nestProviderAstParser");
const implementsForInjectablesThatAreNotProvided = new Set([
    "CanActivate", //(isAGuard)
    "NestInterceptor", //(isAnInterceptor)
    "PipeTransform", //(isAPipeTransform)
    "NestMiddleware", //(isMiddleware)
]);
const NestProvidedInjectableMapper = {
    detectDirectoryToScanForFiles(sourceGlob, currentWorkingDirectory) {
        if (sourceGlob && typeof sourceGlob === "string") {
            return [sourceGlob];
        }
        if (sourceGlob && Array.isArray(sourceGlob)) {
            return sourceGlob;
        }
        console.debug("Injectables should be provided is using cwd for scanning. Consider configuring it in eslintrc.", { currentWorkingDirectory });
        return [currentWorkingDirectory];
    },
    parseFileList(files, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    context) {
        const moduleMaps = new Map();
        files
            .map((f) => {
            const fileContents = NestProvidedInjectableMapper.readFileContents(f.filename);
            const fileAstString = typedTokenHelpers_1.typedTokenHelpers.parseStringToAst(fileContents, f.filename, context);
            return NestProvidedInjectableMapper.mapAllProvidedInjectables(fileAstString, f.filename);
        })
            // eslint-disable-next-line @typescript-eslint/unbound-method
            .filter(NestProvidedInjectableMapper.notEmpty)
            .forEach((m) => moduleMaps.set(m[0], m[1]));
        return moduleMaps;
    },
    notEmpty(value) {
        if (value === null || value === undefined)
            return false;
        return true;
    },
    readFileContents(path) {
        return fs_1.default.readFileSync(path, { encoding: "utf8" });
    },
    isNestInjectableThatIsNeverProvided(node) {
        for (const implementsClass of node.implements || []) {
            if (implementsForInjectablesThatAreNotProvided.has(implementsClass.expression.name)) {
                return true;
            }
        }
        return false;
    },
    mapAllProvidedInjectables(ast, path) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (
            // eslint-disable-next-line no-constant-condition, @typescript-eslint/ban-ts-comment
            // @ts-ignore
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            !unambiguous.isModule(ast)) {
                return null;
            }
            // This does too much and should probably be split up
            // i also assume you would never have multiple of providers, controllers or modules in a file
            // dangerous assumption i guess. i have never seen this done before though.
            // set up the response model
            let nestModuleMap = null;
            // Is this a module?
            const foundNestModuleClass = nestModuleAstParser_1.nestModuleAstParser.findNestModuleClass(ast);
            if (foundNestModuleClass) {
                nestModuleMap = nestModuleAstParser_1.nestModuleAstParser.mapNestModuleDecorator(foundNestModuleClass, path);
                return nestModuleMap;
            }
            // or is this a custom provider that would provide an instance of the class?
            // if it is we map the itentifier it "provide"s. This will only work if it's an identifier
            // it can't be provider for a string literal "provide".
            const foundProviderDeclaration = nestProviderAstParser_1.nestProviderAstParser.findNestProviderVariableDeclaration(ast);
            const provideProperty = nestProviderAstParser_1.nestProviderAstParser.findProvideProperty(foundProviderDeclaration, "provide");
            if (provideProperty) {
                nestModuleMap = nestProviderAstParser_1.nestProviderAstParser.mapNestProviderObject(provideProperty, path);
            }
            return nestModuleMap;
        }
        catch (error) {
            console.error("parse error:", path, error);
            // m.errors.push(error);
            // return m; // can't continue
            return null;
        }
    },
};
exports.default = NestProvidedInjectableMapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdFByb3ZpZGVkSW5qZWN0YWJsZU1hcHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9uZXN0TW9kdWxlcy9uZXN0UHJvdmlkZWRJbmplY3RhYmxlTWFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsNkRBQTZEO0FBQzdELGFBQWE7QUFDYiw2RUFBK0Q7QUFFL0QsNENBQW9CO0FBQ3BCLDREQUF1RDtBQUV2RCwrREFBMEQ7QUFDMUQsbUVBQThEO0FBRTlELE1BQU0sMENBQTBDLEdBQUcsSUFBSSxHQUFHLENBQUM7SUFDdkQsYUFBYSxFQUFFLFlBQVk7SUFDM0IsaUJBQWlCLEVBQUUsbUJBQW1CO0lBQ3RDLGVBQWUsRUFBRSxvQkFBb0I7SUFDckMsZ0JBQWdCLEVBQUUsZ0JBQWdCO0NBQ3JDLENBQUMsQ0FBQztBQUNILE1BQU0sNEJBQTRCLEdBQUc7SUFDakMsNkJBQTZCLENBQ3pCLFVBQXlDLEVBQ3pDLHVCQUErQjtRQUUvQixJQUFJLFVBQVUsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUMvQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDeEIsQ0FBQztRQUVELElBQUksVUFBVSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztZQUMxQyxPQUFPLFVBQVUsQ0FBQztRQUN0QixDQUFDO1FBQ0QsT0FBTyxDQUFDLEtBQUssQ0FDVCxnR0FBZ0csRUFDaEcsRUFBQyx1QkFBdUIsRUFBQyxDQUM1QixDQUFDO1FBQ0YsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNELGFBQWEsQ0FDVCxLQUFpQjtJQUNqQiw4REFBOEQ7SUFDOUQsT0FBbUQ7UUFFbkQsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQXNDLENBQUM7UUFDakUsS0FBSzthQUNB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